{
  "author": {
    "name": "Brian J. Brennan",
    "email": "brianloveswords@gmail.com",
    "url": "http://bjb.io"
  },
  "name": "streampng",
  "description": "Streaming PNG encoder/decoder, compatible with latest PNG extensions (PNGEXT 1.4.0)",
  "version": "0.1.7",
  "homepage": "https://github.com/brianloveswords/streampng",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianloveswords/streampng.git"
  },
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/.bin/tap test/*.test.js"
  },
  "dependencies": {
    "buffer-crc32": "~0.1.1",
    "buffer-equal": "~0.0.0",
    "errs": "~0.2.4",
    "bitwriter": "~0.0.5",
    "bitreader": "~0.0.1"
  },
  "devDependencies": {
    "tap": "~0.2.5"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "# streampng [![Build Status](https://secure.travis-ci.org/brianloveswords/streampng.png?branch=master)](http://travis-ci.org/brianloveswords/streampng)\n\nReading, modifying and (experimentally) writing PNGs, chunk by chunk.\n\n## Install\n\n```bash\n$ npm install streampng\n```\n\n## Tests\n\nRequires [node-tap](/isaacs/node-tap).\n\n```bash\n$ npm test\n```\n\n# API\n\n## StreamPng([*streamOrBuffer*])\n**@returns** `instance`<br>\n**@throws** `TypeError`<br>\n**@see** `Stream#pipe`<br>\n**@see** `StreamPng#write`<br>\n***\n\nInherits from `Stream`. Optionally takes a `Stream` or `Buffer`\ninstance. If the argument is a `Stream`, it will pipe the stream to the new\ninstance. If it's a buffer, the buffer will be passed to `StreamPng#write`.\n\n## Event: 'data'\n`function (data) { }`\n\nEmitted whenever `StreamPng#write` or `StreamPng#end` is called with\ndata. Allows for transparent re-piping.\n\n## Event: 'end'\n`function () { }`\n\nEmitted when the end of the input stream is reached.\n\n## Event: 'error'\n`function (exception) { }`\n\nEmitted when there is an error parsing the PNG.\n\n## Event: 'signature'\n`function () { }`\n\nEmitted after the PNG signature has been verified.\n\n## Event: 'chunk'\n`function (chunk) { }`\n\nEmitted when a full chunk has been parsed.\n\n## Event: chunkType\n`function (chunk) { }`\n\nEmitted when a chunk of a certain type has been parsed. For example,\n\n```js\n// do something with each tEXt chunk\npng.on('tEXt', function(chunk) { ... })\n```\n\n## Event: 'imagedata begin'\n`function () { }`\n\nEmitted when the first `IDAT` chunk is recieved.\n\n## StreamPng#write([*buffer*])\n**@returns** `instance`<br>\n**@emits** `{'data', Buffer}`<br>\n\n***\nWrites data to the internal parser. Does nothing if no arguments are\nrecieved. Emits a `data` event with the buffer that was passed in to\nallow for chaining pipes:\n\n```js\nvar outstream = fs.createWriteStream('node-logo.png');\nvar png = new StreamPng();\nvar opts = url.parse('http://nodejs.org/images/logo.png');\n\nhttp.request(opts, function(res) {\n  res.pipe(png).pipe(outstream);\n}).end();\n\npng.on('chunk', function(chunk) {\n  console.dir(chunk);\n});\n```\nIn general, this shouldn't be called directly. Use `Stream#pipe` or pass\na full buffer via the constructor.\n\n\n## StreamPng#end([*buffer*])\n**@returns** `instance`<br>\n**@emits** `{'end'}`<br>\n**@see** `StreamPng#write`<br>\n***\n\nCalled when the input stream is done (or immediately if a `Buffer` was\npassed to the constructor).\n\nThis probably shouldn't ever have to be called directly.\n\n\n## StreamPng#inject(*chunk, [opts, [conditionFn]]*)\n**@returns** `instance`<br>\n***\n### Options\n- `test`: Either `'all'` or `'same'`. Whether the condition should be\n  checked against all chunks or just chunks of the same type.<br>Defaults\n  to `'same'`.\n\nAdd a chunk to the PNG, optionally with a condition for inclusion.\n\nChunks will be added after directly after the `IHDR`\nchunk. `conditionFn`, if passed, will be called with every chunk of the\nsame type. You can force the condition against every chunk by passing\n`test: 'all'` in the options.\n\nHere is an example of conditionally adding a `tEXt` chunk with a License\nif one doesn't already exist.\n\n```js\n// setup\nvar fs = require('fs'), StreamPng = require('./');\n\nvar instream = fs.createReadStream('example.png');\nvar outfile = fs.createWriteStream('example.license.png');\nvar png = StreamPng(instream);\nvar license = StreamPng.Chunk.tEXt({\n  keyword: 'License',\n  text: 'CC BY-SA 3.0'\n});\n\n// add a `License` text chunk if one doesn't already exist.\n png.inject(license, function(chunk) {\n   if (chunk.get('keyword') === 'License')\n      return false;\n});\n\n// write output to file\npng.out().pipe(outfile);\n```\n**Important**: note the use of `StreamPng#out` before calling pipe â€“\ncalling `pipe()` directly on the instance will pipe the input\ntransparently, without modification.\n\n\n## StreamPng#out([*callback*])\n**@returns** `new Stream`<br>\n***\nOutputs the (potentially modified) PNG buffer. Can be used either\ncallback style or stream style:\n\nCallback example:\n```js\npng.out(function (err, buf) {\n  fs.writeFile('example.png', buf, function() {\n    console.log('done');\n   });\n});\n```\nStream example:\n```js\nvar infile = fs.createWriteStream('example.png');\npng.out().pipe(infile).once('close', function() {\n  console.log('done');\n});\n```\n\n# Common chunk methods\n\nAll chunk constructors take one argument, `fields`, which should be an\nobject defining the fields necessary for the chunk.\n\n## Chunk#set(*key, value*)\n**@returns** `instance`<br>\n***\nSet a chunk attribute. Use this rather than directly accessing\nattributes to ensure that cached buffers are correctly invalidated.\n\n\n## Chunk#get(*key*)\n**@returns** `value`<br>\n***\nGets a chunk attribute.\n\n\n## Chunk#inflate([*callback*])\n**@returns** `instance`<br>\n***\n**Callback**: `function (err, buffer) { }`\n\nFor chunks that have compressed fields (`iTXt`, `zTXt`, `iCCP`),\ninflates the compressed data, sets the appropriate attribute on the\nchunk (`text` for textual data, `profile` for ICC profile data) and\nexecutes callback either either the zlib error or the inflated buffer.\n\n\n## Chunk#length()\n**@returns** `Integer`<br>\n***\n Length of the data portion of the chunk. For the length of the entire\nchunk including length, type and CRC segments, add `12` to the result.\n\n\n## Chunk#getComputedCrc()\n**@returns** `Buffer`<br>\n***\n Calculate the CRC for the chunk.\n\n# Specific chunk attributes\nAll incoming chunks will have `type` and `crc` fields.\n\n\n## Chunk.IHDR, Chunk.ImageHeader\n- `width`: Width of the image in pixels\n- `height`: Height of the image in pixels\n- `colourType`: The type of image. Must be one of the following values:\n  - `IHDR.GREYSCALE`\n  - `IHDR.TRUECOLOUR`\n  - `IHDR.INDEXED_COLOUR`\n  - `IHDR.GREYSCALE_ALPHA`\n  - `IHDR.TRUECOLOUR_ALPHA`\n- `bitDepth`: The following values are valid depending on colour type:\n  - greyscale: `[1, 2, 4, 8 ,16]`\n  - truecolour: `[8, 16]`\n  - indexed: `[1, 2, 4, 8]`\n  - greyscale with alpha: `[8, 16]`\n  - truecolour with alpha: `[8, 16]`\n- `interlaceMethod`: Whether the image is interlaced. The png\n  specification recognizes the following values:\n  - `IHDR.NONE`\n  - `IHDR.ADAM7`: Adam7 style interlacing.\n\n\n## Chunk.tIME, Chunk.LastModified\n- `year`: Four digit year (e.g, 2046)\n- `month`: Month, starting at 1 for January. (valid: 1-12)\n- `day`: Day of the month, starting at 1. (valid: 1-31)\n- `hour`: In 24 hour format (valid: 0-23)\n- `minute`: Minutes (valid: 0-59)\n- `second`: Seconds (valid: 0-60, to allow for leap second)\n\n\n## Chunk.zTXt, Chunk.CompressedText\n- `keyword`: According to the specification, should use Latin-1\n  character set and be less than 79 characters (not  enforced by this\n  implementation).\n- `compressionMethod`: How the image is compressed. The only method\n  currently defined in the png specification is `0`  for zlib deflate/inflate.\n- `text`: Uncompressed  textual data.\n- `compressedText`: Buffer of compressed text.\n\n\n## Chunk.tEXt, Chunk.TextualData\n- `keyword`: According to the specification, should use Latin-1\n  character set and be less than 79 characters (not  enforced by this\n  implementation).\n- `text`: The textual data.\n\n\n## Chunk.iTXt, Chunk.InternationalText\n- `keyword`: According to the specification, should use Latin-1\n  character set and be less than 79 characters (not  enforced by this\n  implementation).\n- `translatedKeyword`: Can be UTF-8. Optional.\n- `languageTag`: Language of the `text` and `translatedKeyword` fields.\n- `compressed`: `true` if the text field should be compressed before\n  outputting, `false` otherwise.\n- `text`: The textual data.\n- `compressedText`: Buffer of compressed text.\n\n\n## Chunk.pHYs, Chunk.PhysicalDimensions\n- `pixelsPerUnit`: How many pixels per unit are there in each\n  dimensions. Can be an array `[1, 10]` or an object `{x: 14, y: 27}`\n- `unitSpecifier`: Valid values are:\n  - `0` for unknown\n  - `1` for meters\n\n\n## Chunk.sPLT, Chunk.SuggestedPalette\n- `paletteName`: The palette name is case-sensitive, and subject to the\n  same restrictions as the keyword parameter for the tEXt chunk. Palette\n  names shall contain only printable Latin-1 characters and spaces (only\n  character codes 32-126 and 161-255 decimal are allowed).\n- `sampleDepth`: The sPLT sample depth shall be 8 or 16.\n- `palette`: An array of objects with the following fields:\n  - `red`: Red component of sample. Max value of 255 or 65535.\n  - `green`: Green component of sample. Max value of 255 or 65535.\n  - `blue`: Blue component of sample. Max value of 255 or 65535.\n  - `alpha`: Alpha component of sample. Max value of 255 or 65535.\n  - `frequency`:  Frequency of sample appearance. Range 0 to 65535\n\n\n## Chunk.iCCP, Chunk.ICCProfile\n- `profileName`: The profile name is case-sensitive, and subject to the\n  same restrictions as the keyword parameter for the tEXt chunk. Palette\n  names shall contain only printable Latin-1 characters and spaces (only\n  character codes 32-126 and 161-255 decimal are allowed).\n- `profile`: Buffer of the profile data.\n- `compressedProfile`: Compressed Buffer of the profile data.\n\n\n## Chunk.sRGB, Chunk.StandardRGBColourSpace\n- `renderingIntent`: Should be one of the following constants:\n  - `sRGB.PERCEPTUAL`, for images preferring good adaptation to the\n    output device gamut at the expense of colorimetric accuracy, such as\n    photographs.\n  - `sRGB.RELATIVE_COLORIMETRIC`, for images requiring colour appearance\n    matching (relative to the output device white point), such as logos.\n  - `sRGB.SATURATION`, for images preferring preservation of saturation\n    at the expense of hue and lightness, such as charts and graphs.\n  - `sRGB.ABSOLUTE_COLORIMETRIC`, for images requiring preservation of\n    absolute colorimetry, such as previews of images destined for a\n    different output device (proofs).\n\n\n## Chunk.sBIT, Chunk.SignificantBits\nAll fields have a range of 0 to image sample depth, inclusive.\n\nWhen type is greyscale:\n- `greyscale`\n\nWhen type is truecolour or indexed colour:\n- `red`\n- `green`\n- `blue`\n\nWhen type is greyscale with alpha\n- `greyscale`\n- `alpha`\n\nWhen type is truecolour with alpha\n- `red`\n- `green`\n- `blue`\n- `alpha`\n\n\n## Chunk.gAMA, Chunk.Gamma\n- `gamma`: Float representing the image gamma.\n\n\n## Chunk.cHRM, Chunk.Chromaticities\nOptional. If present, can appear exactly once.\n\nAll fields can be arrays in the form of `[x, y]` or objects with\n`{ x: value, y : value}`\n\n- `whitePoint`\n- `red`\n- `green`\n- `blue`\n\n\n## Chunk.PLTE, Chunk.Palette\nCan appear exactly once. Required for images of type 3, optional for\ntypes 2 and 6. Must not appear for types 0 and 4.\n\n-`colours`: Array of objects. Max length of 256, all values must be\n between 0-255\n  - `red`\n  - `green`\n  - `blue`\n\n\n## Chunk.tRNS, Chunk.Transparency\nSpecifies either alpha values that are associated with palette entries\n(for indexed-colour images) or a single transparent colour (for\ngreyscale and truecolour images).\n\nType 0, value between 0 and (2<sup>bitdepth</sup>-1)\n- `greyscale`: 0-65535\n\nType 2, all values between 0 and (2<sup>bitdepth</sup>-1)\n- `red`\n- `green`\n- `blue`\n\nType 3, all values between 0 and 255\n- `palette`: Array ordered by palette index.\n\n\n## Chunk.hIST, Chunk.Histogram\nGives the approximate usage frequency of each colour in the palette. A\nhistogram chunk can appear only when a PLTE chunk appears.\n\n- `frequencies`\n\n\n## Chunk.bKGD, Chunk.BackgroundColour\nSpecifies a default background colour to present the image\nagainst. Optional; if present, must appear no more than once.\n\ngreyscale types:\n- `greyscale`: Between 0 and (2<sup>bitdepth</sup>-1)\n\ntruecolour types, all values between 0 and (2<sup>bitdepth</sup>-1)\n- `red`\n- `green`\n- `blue`\n\nindex colour:\n- `paletteIndex`: Index of the palette entry to be used as the\n  background.\n\n\n## Chunk.IDAT, Chunk.ImageData\nContains the actual image data which is the output stream of the\ncompression algorithm\n\n- `data`: compressed image data.\n\n## Chunk.IEND, Chunk.ImageTrailer\nMarks the end of the PNG datastream. The chunk's data field is empty.\n\n\n## Chunk.oFFs, Chunk.Offset\nGives the position on a printed page at which the image should be output\nwhen printed alone. It can also be used to define the image's location\nwith respect to a larger screen or other application-specific coordinate\nsystem.\n\n- `position`: Position on the page, accessible by `[x, y]` or\n`{x:  value, y: value}`. Value is a signed 32-bit integer.\n\n- `unitSpecifier`: One of the following constants:\n  - `oFFs.PIXELS`: unit is pixels\n  - `oFFs.MICRONS`: unit is microns\n\n\n## Chunk.pCAL, Chunk.PixelCalibration\nWhen a PNG file is being used to store physical data other than color\nvalues, such as a two-dimensional temperature field, the pCAL chunk can\nbe used to record the relationship (mapping) between stored pixel\nsamples, original samples, and actual physical values. The pCAL data\nmight be used to construct a reference color bar beside the image, or to\nextract the original physical data values from the file. It is not\nexpected to affect the way the pixels are displayed. Another method\nshould be used if the encoder wants the decoder to modify the sample\nvalues for display purposes.\n\n- `name`: The calibration name is case-sensitive, and subject to the\n  same restrictions as the keyword parameter for the tEXt chunk. Palette\n  names shall contain only printable Latin-1 characters and spaces (only\n  character codes 32-126 and 161-255 decimal are allowed).\n- `originalZero`: 32-bit signed integer.\n- `originalMaximum`: 32-bit signed integer.\n- `equationType`: Defines the pixel mapping equation: One of the\n  following constants:\n  - `pCAL.LINEAR`\n  - `pCAL.BASE_E_EXPONENTAL`\n  - `pCAL.ARIBTRARY_BASE_EXPONENTIAL`\n  - `pCAL.HYPERBOLIC`\n- `parameters`: Array of `n` length where `n=2` for linear, `n=3` for\n  either of the exponential types and `n=4` for hyperbolic\n  equations. Contains objects with:\n  - `unit`: Unit name\n  - `parameter`: Value of the parameter\n\n\n## Chunk.sCAL, Chunk.Scale\nWhile the pHYs chunk is used to record the physical size of the image\nitself as it was scanned or as it should be printed, certain images\n(such as maps, photomicrographs, astronomical surveys, floor plans, and\nothers) may benefit from knowing the actual physical dimensions of the\nimage's subject for remote measurement and other purposes. The sCAL\nchunk serves this need.\n\n- `unitSpecifier`: The following constants are defined:\n  - `sCAL.METERS`: Units are meters\n  - `sCAL.RADIANS`: Units are radians\n- `width`: Floating point representing the unit width per pixel.\n- `height`: Floating point representing the unit height per pixel.\n\n\n## Chunk.gIFg, Chunk.GifControl\nThe gIFg chunk is provided for backward compatibility with the GIF89a\nGraphic Control Extension.\n\n- `disposalMethod`: The following constants are defined\n  - `gIFg.NONE`\n  - `gIFg.BACKGROUND`\n  - `gIFg.PREVIOUS`\n- `userInput`: Whether or not user input is required to activate\n  animate. Defaults to `false`.\n- `delay`: How long between frames in hundredths of seconds.\n\n\n## Chunk.gIFx, Chunk.GifApplication\nThe gIFx chunk is provided for backward compatibility with the GIF89a\nApplication Extension. The Application Extension contains\napplication-specific information.\n\n- `appIdentifier`: Up to  eight printable ASCII characters used to\n  identify the application\n- `authCode`: Buffer, application specific. Up to three bytes.\n- `appData`: Buffer, application specific.\n\n\n## Chunk.sTER, Chunk.Stereogram\nWhen present, the sTER chunk indicates that the datastream contains a\nstereo pair of subimages within a single PNG image.\n\n- `mode`: One of the following constants:\n  - `sTER.CROSS_FUSE`: right-eye image appears at the left and the\n    left-eye image appears at the right, suitable for cross-eyed free\n    viewing.\n\n  - `sTER.DIVERGING_FUSE`: left-eye image appears at the left and the\n    right-eye image appears at the right, suitable for divergent\n    (wall-eyed) free viewing.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/brianloveswords/streampng/issues"
  },
  "_id": "streampng@0.1.7",
  "_from": "streampng@0.1.7"
}
