{
  "author": {
    "name": "Brian J. Brennan",
    "email": "brianloveswords@gmail.com",
    "url": "http://bjb.io"
  },
  "name": "bitwriter",
  "description": "A better interface for writing bytes to Buffers",
  "version": "0.0.5",
  "homepage": "https://github.com/brianloveswords/bitwriter",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianloveswords/bitwriter.git"
  },
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/.bin/tap test/*.test.js"
  },
  "dependencies": {
    "errs": "~0.2.4"
  },
  "devDependencies": {
    "tap": "~0.2.5"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "# bitwriter [![Build Status](https://secure.travis-ci.org/brianloveswords/bitwriter.png?branch=master)](http://travis-ci.org/brianloveswords/bitwriter)\n\nA better interface for writing bytes to a buffer with a priority on safety.\n\n## Install\n\n```bash\n$ npm install bitwriter\n```\n\n## Tests\n\n```bash\n$ npm test\n```\n\n## Usage\n\n```js\nvar BitWriter = require('bitwriter');\n```\n\n# API\n`BitWriter` Inherits from `Buffer`, so you get all of the buffer methods\n(`fill`, `slice`, `copy`, etc) as well. You can also use `Buffer.concat`\nwith instances.\n\n## BitWriter(*length, [endianness='BE']*)\n\n```js\nvar buf = BitWriter(4); \nbuf.inspect(); // <BitWriter 00 00 00 00>\n\n// or if you need a little endian writer\nbuf = BitWriter(4, 'LE');\n```\n## BitWriter(*array, [endianness='BE']*)\n**@see** `BitWriter#writeInt`<br>\n***\n\nYou can also specify an array of integers or objects representing\nintegers. Uses `BitWriter#writeInt` internally.\n\n```js\nvar buf = BitWriter([ 1, 2, 64738, 23 ]);\nbuf.out(); // <Buffer 01 02 fc e2 17>\n  \nvar obuf = BitWriter([ 1, 2, 64738, { value: 23, width: 16 } ]);\nobuf.out(); // <Buffer 01 02 fc e2 00 17>\n```\n\n## BitWriter#write(*data, [opts]*)\n**@returns** `this`<br>\n**@see** `BitWriter#writeInt`<br>\n**@see** `BitWriter#writeString`<br>\n**@see** `BitWriter#writeRaw`\n***\n\nMake some assumptions and does its best to figure out what type of data you're\nwriting and how large that data is, then delegates to one of the write methods below.\n\n## BitWriter#out()\n**@returns** `{Buffer}`<br>\n\nReturns reference to internal buffer.\n\n\n## BitWriter#writeRaw(*arraylike, [opts]*)\n**@returns** `this`<br>\n**@throws** `TypeError`<br>\n**@throws** `RangeError`<br>\n**@see** `BitWriter#write8`<br>\n**@see** `Buffer#copy`\n***\nTakes an array-like object and iterates through it, writing raw bytes to\nthe buffer.\n\nArrays are type-checked to be byte arrays and range-checked for values between [0, 255]. \n\nDelegates to `Buffer#copy` if given a buffer, which skips type checks\nand is generally way more efficient.\n\n```js\nvar buf = BitWriter(8);\nbuf.write([0xff, 0xdd, 0xaa, 0xbb]); // <BitWriter ff dd aa bb 00 00 00 00>\nbuf.write(Buffer('helo')); // <BitWriter ff dd aa bb 68 65 6c 6f>\n```\n\nIf `opts.safe` is `true`, will skip type checks which is a bit more efficient\nsince it will only iterate over the array once, but can be dangerous\nwith unknown data.\n \nThrows `TypeError` if the array contains any non-numeric values.\n\nThrows `RangeError` if any values are outside the eight bit range.\n\n\n## BitWriter#writeString(*string, [opts]*)\n**@returns** `this`<br>\n**@throws** `OverflowError`\n***\n\nWrites a string to the buffer. By default, a single `0x00` will be added\nafter the string if there is room left in the buffer.\n\n```js\nvar buf = BitWriter(7);\nbuf.write('hey'); // <BitWriter 68 65 79 00 00 00 00>\nbuf.write('sup'); // <BitWriter 68 65 79 00 73 75 70>\n```\n\nIf you don't want to write a null byte, you can pass an `{ null: false }`\n```js\nvar buf = BitWriter(6);\nbuf.write('hey', { null: false }); // <BitWriter 68 65 79 00 00 00 >\nbuf.write('sup'); // <BitWriter 68 65 79 73 75 70>\n```\n\nIf you have a specific amount of bytes you need to fit a string into,\nyou can use `{ size: <int> }`. This will either truncate the string to\nfit, or pad the right side with `0x00`.\n\n```js\nvar buf = BitWriter(4);\nbuf.write('hey this string is way too long!', { size: 4 });\nbuf.inspect(); // <BitWriter 68 65 79 20>\n```\n\nThrows `OverflowError` if there are less than `string.length` bytes left\nin the buffer.\n\n\n## BitWriter#writeInt(*integer, [opts]*)\n## BitWriter#writeInt(*opts*)\n**@returns** `this`<br>\n**@throws** `RangeError`<br>\n**@throws** `TypeError`<br>\n**@throws** `OverflowError`<br>\n**@throws** `DispatchError`<br>\n*** \n### Options\n- `size`: specify integer size\n- `width`: alias for size\n\nWrites an integer to the buffer, testing against the maximum and minimum\nvalues 8, 16 and 32 bit numbers, both signed and unsigned, to figure out\nhow best to store your bytes.\n\nIf a single object is passed, tries to find the integer value from `opts.value`.\n\n**Unsigned integers**\n```js\nvar buf = BitWriter(8);\nbuf.write(128); //<BitWriter 80 00 00 00 00 00 00 00>\n```\n\n**Signed integers**\n```js\nbuf.write(-1); // <BitWriter 80 ff 00 00 00 00 00 00>\n```\n\n**16 bits**\n```js\nbuf.write(61453); // <BitWriter 80 ff f0 0d 00 00 00 00>\n```\n\n**32 bits**\n```js\nbuf.write(262254561); // <BitWriter 80 ff f0 0d 0f a1 af e1>\n```\nIf you have a number that fits in 8 bytes but you need to store it in a larger\nsize, you can specify that:\n\n```js\nvar buf = BitWriter(4);\nbuf.write(-128, { size: 32 }); // <BitWriter ff ff ff 80>\n```\n\nReturns `this` so you can chain a bunch of writes:\n\n```js\nvar output = BitWriter(4);\noutput\n  .write(0x01)\n  .write(0x02)\n  .write(0x03)\n  .write(0x04); // <BitWriter 01 02 03 04>\n```\n\nThrows `TypeError` if it gets a string that is not completely composed\nof digits.\n\nThrows `RangeError` an invalid `size` option is given. Valid sizes can\nbe found in the constant `BitWriter.INT_SIZES` (currently\n`[8, 16, 32]`).\n\nThrows `RangeError` if the value is less than the minimum value of a\n32 bit signed integer or the maximum value of a 32 bit unsigned\ninteger. These values can be found in `BitWriter.MAX_VALUE` and\n`BitWriter.MIN_VALUE`\n\nThrows `OverflowError` when attempting to write more bytes than are\navailable in the buffer.\n\nThrows `DispatchError` if it can't figure out what to do with a value.\n\n\n## BitWriter#write8(*integer*)\nConvenience for `BitWriter#write(integer, { size: 8 })`\n\n## BitWriter#write16(*integer*)\nConvenience for `BitWriter#write(integer, { size: 16 })`\n\n## BitWriter#write32(*integer*)\nConvenience for `BitWriter#write(integer, { size: 32 })`\n\n## BitWriter[*length-1*], BitWriter[*length-1*] = [-128, 255]\n**@returns** `{Integer[0,255] | Undefined}`<br>\n**@throws** `RangeError`\n*** \n \nExactly like array accessing a `Buffer` with one difference: this will\nthrow `RangeError` if the value is less than -128 or greater than 255\n\nAccessing a position < 0 or > `length - 1` will return undefined.\n\n\n## BitWriter#reset()\n**@returns** `this`.\n***\n \nResets the internal cursor to position 0 and fills the buffer with `0x00`.\n\n\n\n## BitWriter#position()\n**@returns** `{Integer}`\n*** \n \n Returns the position of the internal cursor\n\n\n## BitWriter#position(*integer*)\n**@returns** `this` <br>\n**@throws** `RangeError`<br>\n**@throws** `TypeError`\n*** \n \nSets the position of the internal cursor. Value be between [0, length-1]\n\nThrows `RangeError` if position is out of bounds.\n\nThrows `TypeError` if input is not a number.\n\n## BitWriter#move(*integer*)\n**@returns** `this` <br>\n**@see** `BitWriter#position`\n\nMove the cursor a relative amount from where it is. Uses `BitWriter#position` internally.\n\n```js\nvar buf = BitWriter(4);\nbuf.write(0x3d);\nbuf.position(); // 1\nbuf.move(-1);\nbuf.position(); // 0\nbuf.move(+3)\nbuf.position(); // 3\n\nbuf.move(+10); // throw RangeError\n```\n\n## BitWriter#attach(*object, [key]*)\n**@returns** `object` <br>\n***\n\nThis attachs hard `this`-bound versions of the `write*` methods  to another object.\n\n```js\nvar meta = BitWriter(16).attach({\n  name: 'SomeThing',\n  widgets: [],\n}, 'data');\n\nmeta.write('widget co');\nmeta.write32(0xff);\nmeta.data.inspect(); // <BitWriter 77 69 64 67 65 74 20 63 6f 00 00 00 ff 00 00 00>\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/brianloveswords/bitwriter/issues"
  },
  "_id": "bitwriter@0.0.5",
  "_from": "bitwriter@~0.0.5"
}
